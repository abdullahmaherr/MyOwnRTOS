/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 *******************************************************************************/

/*===============================================================================
 *                                Includes                                       *
 ================================================================================*/
#include <stdio.h>
#include <stdlib.h>

#include <core_cm3.h>

#include "stm32f103c8.h"
#include "stm32f103c8_rcc_driver.h"
#include "stm32f103c8_gpio_driver.h"
#include "stm32f103c8_exti_driver.h"

/*===============================================================================
 *                       		 	Macros			                             *
 ================================================================================*/
#define TASK_A_STACK_SIZE 		100
#define TASK_B_STACK_SIZE 		100


#define SET_SP_TO_MSP()					__asm volatile("mrs r0, CONTROL \n\t 	mov r1,#0x05 \n\t 	and r0,r0,r1 \n\t 	msr CONTROL,r0")
#define SET_SP_TO_PSP()					__asm volatile("mrs r0, CONTROL \n\t 	mov r1,#0x02 \n\t 	orr r0,r0,r1 \n\t 	msr CONTROL,r0")

#define UNPRIVILEGED_ACCESS_LEVEL()		__asm volatile("mrs r0, CONTROL \n\t 	mov r1,#0x01 \n\t 	orr r0,r0,r1 \n\t 	msr CONTROL,r0")
#define PRIVILEGED_ACCESS_LEVEL()		__asm volatile("mrs r0, CONTROL \n\t 	mov r1,#0x06 \n\t 	and r0,r0,r1 \n\t 	msr CONTROL,r0")

#define SET_PSP(ADDRESS)				__asm volatile("mov r0,%[in0] \n\t msr PSP,r0" : :[in0] "r" (ADDRESS))

#define OS_Generate_Exception()			__asm volatile("SVC #0x03")

/*===============================================================================
 *                              Global Variables                                 *
 ================================================================================*/
extern uint32_t _estack;

uint32_t _S_MSP = (uint32_t)&_estack;		/*_estack is sympol*/
uint32_t _E_MSP;

uint32_t _S_PSP_TSAK_A;
uint32_t _E_PSP_TSAK_A;

uint32_t _S_PSP_TSAK_B;
uint32_t _E_PSP_TSAK_B;


vuint8_t IRQ_Flag = 0;
vuint8_t TASK_A_Flag = 0;
vuint8_t TASK_B_Flag = 0;
vuint8_t rseTaskA = 0;
vuint8_t rseTaskB = 0;

/*===============================================================================
 *     		       		 	ISR Functions Definition 		                     *
 ================================================================================*/
__attribute((naked)) void SVC_Handler(void)
{
	__asm(	"TST LR, #4		\n\t"
			"ITE EQ			\n\t"
			"MRSEQ R0,MSP	\n\t"
			"MRSNE R0,MSP	\n\t"
			"B OS_SVC_services"
			);
}

void EXTI9_CALLBACK(void)
{
	if(IRQ_Flag == 0)
	{
		IRQ_Flag = 1;
		TASK_A_Flag = 1;
		TASK_B_Flag = 0;
	}else if(IRQ_Flag == 1)
	{
		IRQ_Flag = 0;
		TASK_A_Flag = 0;
		TASK_B_Flag = 1;
	}
}


/*===============================================================================
 *                                Application                                    *
 ================================================================================*/
void OS_SVC_services(uint32_t* p_StackFrame)
{
	/* 	Stack -> R0 -> Argument0 = p_StackFrame */
	uint8_t SVC_serviceNumber;
	uint32_t stacked_R0,stacked_R1,stacked_R2,stacked_R3,stacked_R12,stacked_LR,stacked_PC,stacked_xPSR;

	SVC_serviceNumber = (((uint8_t*)p_StackFrame[6])[-2]);

	stacked_R0 = p_StackFrame[0];
	stacked_R1 = p_StackFrame[1];
	stacked_R2 = p_StackFrame[2];
	stacked_R3 = p_StackFrame[3];
	stacked_R12 = p_StackFrame[4];
	stacked_LR = p_StackFrame[5];
	stacked_PC = p_StackFrame[6];
	stacked_xPSR = p_StackFrame[7];

}
int TASK_A(int a,int b,int c)
{
	return a+b+c;
}

int TASK_B(int a,int b,int c,int d)
{
	return a+b+c+d;
}

void os_op(void)
{
	/* Main Stack */
	_E_MSP = (_S_MSP - 512);

	/* Task A Stack */
	_S_PSP_TSAK_A = (_E_MSP - 8);
	_E_PSP_TSAK_A = (_S_PSP_TSAK_A - TASK_A_STACK_SIZE);

	/* Task B Stack */
	_S_PSP_TSAK_B = (_E_PSP_TSAK_A - 8);
	_E_PSP_TSAK_B = (_S_PSP_TSAK_B - TASK_B_STACK_SIZE);


	while(1)
	{
		if(TASK_A_Flag == 1)
		{
			TASK_A_Flag = 0;
			SET_PSP(_S_PSP_TSAK_A);/* Set PSP To TASK A Stack */
			SET_SP_TO_PSP();/* SP->PSP */
			UNPRIVILEGED_ACCESS_LEVEL(); /*Privileged -> Unprivileged */

			rseTaskA = TASK_A(1,2,3);

			OS_Generate_Exception();
			SET_SP_TO_MSP();/* SP->MSP */

		}else if(TASK_B_Flag == 1)
		{
			TASK_B_Flag = 0;
			SET_PSP(_S_PSP_TSAK_B);/* Set PSP To TASK B Stack */
			SET_SP_TO_PSP();/* SP->PSP */
			UNPRIVILEGED_ACCESS_LEVEL(); /*Privileged -> Unprivileged */

			rseTaskB = TASK_B(1,2,3,4);

			OS_Generate_Exception();
			SET_SP_TO_MSP();/* SP->MSP */
		}
	}
}

void RCC_Init(void)
{
	/* Initialize System Clock  */
	MCAL_RCC_initSYSClk();

	/* Initialize Peripherals */
	MCAL_RCC_enableCLK(RCC_APB2_BUS, RCC_GPIOB_ID);
	MCAL_RCC_enableCLK(RCC_APB2_BUS, RCC_AFIO_ID);

}


int main(void)
{
	RCC_Init();

	/* Set EXTI Configuration */
	EXTI_PinConfig_t exti_conf;
	exti_conf.EXTIx_Pin = EXTI9PB9;
	exti_conf.EXTI_TriggerCase = EXTI_RAISING_TRIG;
	exti_conf.p_EXTI_ISR_CallBack = EXTI9_CALLBACK;
	exti_conf.EXTI_IRQ = EXTI_IRQ_ENABLE;
	MCAL_EXTI_GPIO_Init(&exti_conf);

	os_op();
	IRQ_Flag = 1;

	while(1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else { /* Misra */ }
	}
}
